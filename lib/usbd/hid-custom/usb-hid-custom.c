/*
* Copyright (c) 2018 Vladimir Alemasov
* All rights reserved
*
* This program and the accompanying materials are distributed under 
* the terms of GNU General Public License version 2 
* as published by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*/

#include "platform.h"
#include "usbd_core.h"
#include "usb_std.h"
#include "hal-usbd-init.h"
#include "usb_hid.h"
#include <string.h>

//--------------------------------------------
#ifdef USBD_OTGFS
extern const struct usbd_driver usbd_otgfs;
#define usbd_hw usbd_otgfs
#elif defined USBD_OTGHS || defined USBD_OTGHS_FS
extern const struct usbd_driver usbd_otghs;
#define usbd_hw usbd_otghs
#endif

//--------------------------------------------
#define HID_EP0_SIZE    64
#define HID_RXD_EP      0x01
#define HID_TXD_EP      0x82
#define HID_DATA_SZ     0x02
#define HID_DATA_INT    0x20

//--------------------------------------------
#pragma pack(push, 1)
typedef struct hid_config
{
	struct usb_config_descriptor        config;
	struct usb_interface_descriptor     comm;
	struct usb_hid_descriptor           hid;
	struct usb_endpoint_descriptor      data_eprx;
	struct usb_endpoint_descriptor      data_eptx;
} cdc_config_t;
#pragma pack(pop)

//--------------------------------------------
static const struct usb_device_descriptor device_desc =
{
	.bLength            = sizeof(struct usb_device_descriptor),
	.bDescriptorType    = USB_DTYPE_DEVICE,
	.bcdUSB             = CPU_TO_LE16(VERSION_BCD(2,0,0)),
	.bDeviceClass       = USB_CLASS_PER_INTERFACE,
	.bDeviceSubClass    = USB_SUBCLASS_NONE,
	.bDeviceProtocol    = USB_PROTO_NONE,
	.bMaxPacketSize0    = HID_EP0_SIZE,
	.idVendor           = CPU_TO_LE16(0x0483),
	.idProduct          = CPU_TO_LE16(0x5740),
	.bcdDevice          = CPU_TO_LE16(VERSION_BCD(1,0,0)),
	.iManufacturer      = 1,
	.iProduct           = 2,
	.iSerialNumber      = INTSERIALNO_DESCRIPTOR,
	.bNumConfigurations = 1,
};

//--------------------------------------------
// generated by HID Descriptor Tool
static uint8_t report_desc[] =
{
    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
    0x09, 0x01,                    // USAGE (Vendor Usage 1)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x85, 0x01,                    //   REPORT_ID (1)
    0x09, 0x01,                    //   USAGE (Vendor Usage 1)
    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
    0x75, 0x08,                    //   REPORT_SIZE (8)
    0x95, 0x01,                    //   REPORT_COUNT (1)
    0x85, 0x01,                    //   REPORT_ID (1)
    0x09, 0x01,                    //   USAGE (Vendor Usage 1)
    0x91, 0x82,                    //   OUTPUT (Data,Var,Abs,Vol)
    0x85, 0x02,                    //   REPORT_ID (2)
    0x09, 0x02,                    //   USAGE (Vendor Usage 2)
    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
    0x75, 0x08,                    //   REPORT_SIZE (8)
    0x95, 0x01,                    //   REPORT_COUNT (1)
    0x85, 0x02,                    //   REPORT_ID (2)
    0x09, 0x02,                    //   USAGE (Vendor Usage 2)
    0x91, 0x82,                    //   OUTPUT (Data,Var,Abs,Vol)
    0x85, 0x03,                    //   REPORT_ID (3)
    0x09, 0x03,                    //   USAGE (Vendor Usage 3)
    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
    0x75, 0x08,                    //   REPORT_SIZE (8)
    0x95, 0x01,                    //   REPORT_COUNT (1)
    0x85, 0x03,                    //   REPORT_ID (3)
    0x09, 0x03,                    //   USAGE (Vendor Usage 3)
    0x81, 0x82,                    //   INPUT (Data,Var,Abs,Vol)
    0x85, 0x04,                    //   REPORT_ID (4)
    0x09, 0x04,                    //   USAGE (Vendor Usage 4)
    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
    0x75, 0x08,                    //   REPORT_SIZE (8)
    0x95, 0x01,                    //   REPORT_COUNT (1)
    0x85, 0x04,                    //   REPORT_ID (4)
    0x09, 0x04,                    //   USAGE (Vendor Usage 4)
    0x81, 0x82,                    //   INPUT (Data,Var,Abs,Vol)
    0xc0                           // END_COLLECTION
};

//--------------------------------------------
static const struct hid_config config_desc =
{
	.config =
	{
		.bLength                = sizeof(struct usb_config_descriptor),
		.bDescriptorType        = USB_DTYPE_CONFIGURATION,
		.wTotalLength           = CPU_TO_LE16(sizeof(struct hid_config)),
		.bNumInterfaces         = 1,
		.bConfigurationValue    = 1,
		.iConfiguration         = NO_DESCRIPTOR,
		.bmAttributes           = USB_CFG_ATTR_RESERVED | USB_CFG_ATTR_SELFPOWERED,
		.bMaxPower              = USB_CFG_POWER_MA(100),
	},
	.comm =
	{
		.bLength                = sizeof(struct usb_interface_descriptor),
		.bDescriptorType        = USB_DTYPE_INTERFACE,
		.bInterfaceNumber       = 0,
		.bAlternateSetting      = 0,
		.bNumEndpoints          = 2,
		.bInterfaceClass        = USB_CLASS_HID,
		.bInterfaceSubClass     = USB_HID_SUBCLASS_NONBOOT,
		.bInterfaceProtocol     = USB_HID_PROTO_NONBOOT,
		.iInterface             = NO_DESCRIPTOR,
	},
	.hid =
	{
		.bLength                = sizeof(struct usb_hid_descriptor),
		.bDescriptorType        = USB_DTYPE_HID,
		.bcdHID                 = VERSION_BCD(1,1,1),
		.bCountryCode           = USB_HID_COUNTRY_NONE,
		.bNumDescriptors        = 1,
		.bDescriptorType0       = USB_DTYPE_HID_REPORT,
		.wDescriptorLength0     = sizeof(report_desc),
	},
	.data_eprx =
	{
		.bLength                = sizeof(struct usb_endpoint_descriptor),
		.bDescriptorType        = USB_DTYPE_ENDPOINT,
		.bEndpointAddress       = HID_RXD_EP,
		.bmAttributes           = USB_EPTYPE_INTERRUPT,
		.wMaxPacketSize         = CPU_TO_LE16(HID_DATA_SZ),
		.bInterval              = HID_DATA_INT,
	},
	.data_eptx =
	{
		.bLength                = sizeof(struct usb_endpoint_descriptor),
		.bDescriptorType        = USB_DTYPE_ENDPOINT,
		.bEndpointAddress       = HID_TXD_EP,
		.bmAttributes           = USB_EPTYPE_INTERRUPT,
		.wMaxPacketSize         = CPU_TO_LE16(HID_DATA_SZ),
		.bInterval              = HID_DATA_INT,
	},
};

//--------------------------------------------
static const struct usb_string_descriptor lang_desc = USB_ARRAY_DESC(USB_LANGID_ENG_US);
static const struct usb_string_descriptor manuf_desc_en = USB_STRING_DESC("Homemcu firmware examples");
static const struct usb_string_descriptor prod_desc_en = USB_STRING_DESC("Custom HID demo");
static const struct usb_string_descriptor *const dtable[] =
{
	&lang_desc,
	&manuf_desc_en,
	&prod_desc_en,
};

//--------------------------------------------
static usbd_device udev;
static uint8_t idle_duration;
// Due to use with USB FIFO and/or DMA, the data buffers below must be 32-bit aligned:
#define USB_CTRL_BUFF_SZ 32
static uint32_t ubuf[(USB_CTRL_BUFF_SZ + 3) / sizeof(uint32_t)];
static uint32_t rx_buf[(HID_DATA_SZ + 3) / sizeof(uint32_t)];
static uint32_t tx_buf[(HID_DATA_SZ + 3) / sizeof(uint32_t)];

//--------------------------------------------
static usbd_respond hid_getdesc(usbd_ctlreq *req, void **address, uint16_t *length)
{
	uint8_t dtype = req->wValue >> 8;
	uint8_t dnumber = req->wValue;
	const void* desc;
	uint16_t len = 0;

	switch (dtype)
	{
	case USB_DTYPE_DEVICE:
		desc = &device_desc;
		break;
	case USB_DTYPE_CONFIGURATION:
		desc = &config_desc;
		len = sizeof(config_desc);
		break;
	case USB_DTYPE_STRING:
		if (dnumber < sizeof(dtable) / sizeof(dtable[0]))
		{
			desc = dtable[dnumber];
		}
		else
		{
			return usbd_fail;
		}
		break;
	default:
		return usbd_fail;
	}
	if (len == 0)
	{
		len = ((struct usb_header_descriptor*)desc)->bLength;
	}
	*address = (void*)desc;
	*length = len;
	return usbd_ack;
};

//--------------------------------------------
static usbd_respond hid_control(usbd_device *dev, usbd_ctlreq *req, usbd_rqc_callback *callback)
{
	if (((USB_REQ_RECIPIENT | USB_REQ_TYPE) & req->bmRequestType) != (USB_REQ_INTERFACE | USB_REQ_CLASS))
	{
		uint8_t dtype = req->wValue >> 8;
		if (dtype == USB_DTYPE_HID_REPORT)
		{
			// Standard request to the interface like USB_DTYPE_HID_REPORT
			// cannot be caught in the hid_getdesc function
			// So this request is processed here
			dev->status.data_ptr = &report_desc;
			dev->status.data_count = sizeof(report_desc);
			return usbd_ack;
		}
		return usbd_fail;
	}
	switch (req->bRequest)
	{
	case USB_HID_GETREPORT:
		return usbd_fail;
	case USB_HID_GETIDLE:
		dev->status.data_ptr = &idle_duration;
		dev->status.data_count = 1;
		return usbd_ack;
	case USB_HID_GETPROTOCOL:
		return usbd_fail;
	case USB_HID_SETREPORT:
		// If no Interrupt Out endpoint is declared then Output reports are transmitted
		// to a device through the Control endpoint, using Set_Report(Output) requests.
		return usbd_fail;
	case USB_HID_SETIDLE:
		idle_duration = req->wValue >> 8;
		return usbd_ack;
	case USB_HID_SETPROTOCOL:
		return usbd_fail;
	default:
		return usbd_fail;
	}
}

//--------------------------------------------
static void hid_callback(usbd_device *dev, uint8_t event, uint8_t ep)
{
	uint8_t *rx = (uint8_t *)rx_buf;
	uint8_t *tx = (uint8_t *)tx_buf;

	switch (event)
	{
	case usbd_evt_eprx:
		usbd_ep_read(dev, HID_RXD_EP, rx_buf, HID_DATA_SZ);
		switch (*rx)
		{
		case 1:
			*tx = 0x03;
			*(tx + 1) = *(rx + 1);
			break;
		case 2:
			*tx = 0x04;
			*(tx + 1) = *(rx + 1);
			break;
		default:
			break;
		}
	case usbd_evt_eptx:
		usbd_ep_write(dev, HID_TXD_EP, tx_buf, HID_DATA_SZ);
		break;
	default:
		break;
	}
}

//--------------------------------------------
static usbd_respond hid_setconf(usbd_device *dev, uint8_t cfg)
{
	switch (cfg)
	{
	case 0:
		// deconfiguring device
		usbd_ep_deconfig(dev, HID_RXD_EP);
		usbd_ep_deconfig(dev, HID_TXD_EP);
		usbd_reg_endpoint(dev, HID_RXD_EP, NULL);
		usbd_reg_endpoint(dev, HID_TXD_EP, NULL);
		return usbd_ack;
	case 1:
        // configuring device
		usbd_ep_config(dev, HID_RXD_EP, USB_EPTYPE_BULK, HID_DATA_SZ);
		usbd_ep_config(dev, HID_TXD_EP, USB_EPTYPE_BULK, HID_DATA_SZ);
		usbd_reg_endpoint(dev, HID_RXD_EP, hid_callback);
		usbd_reg_endpoint(dev, HID_TXD_EP, hid_callback);
		return usbd_ack;
	default:
		return usbd_fail;
	}
}

//--------------------------------------------
void usb_hid_custom_init(void)
{
	usbd_hw_init(&udev);
	usbd_init(&udev, &usbd_hw, HID_EP0_SIZE, ubuf, sizeof(ubuf));
	usbd_reg_control(&udev, hid_control);
	usbd_reg_config(&udev, hid_setconf);
	usbd_reg_descr(&udev, hid_getdesc);
}

//--------------------------------------------
void usb_hid_custom_loop(void)
{
	usbd_enable(&udev, true);
	usbd_connect(&udev, true);
	while (1);
}
