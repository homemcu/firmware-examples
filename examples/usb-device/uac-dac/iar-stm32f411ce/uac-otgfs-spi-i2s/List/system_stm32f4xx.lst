###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         09/Jan/2021  10:06:22
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Programming\Microcontrollers\Devices\3rd-party\drivers\cmsis\device\ST\STM32F4xx\Source\Templates\system_stm32f4xx.c
#    Command line      =
#        -f C:\Users\18EE~1\AppData\Local\Temp\EW79BD.tmp
#        (C:\Programming\Microcontrollers\Devices\3rd-party\drivers\cmsis\device\ST\STM32F4xx\Source\Templates\system_stm32f4xx.c
#        -D STM32F411xE -D HSE_VALUE=25000000 -D USBD_OTGFS --preprocess=s
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\uac-otgfs-spi-i2s\List
#        -lcN
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\uac-otgfs-spi-i2s\List
#        -o
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\uac-otgfs-spi-i2s\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\..\src\
#        -I
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\..\..\..\..\hal\inc\
#        -I
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\..\..\..\..\drv\audio-out\
#        -I
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\..\..\..\..\lib\usbd\class\
#        -I
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\..\..\..\..\lib\usbd\uac-dac\
#        -I
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\..\..\..\..\cpu\stm32f411ce\
#        -I
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\..\..\..\..\platform\
#        -I
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\..\..\..\..\3rd-party\drivers\cmsis\core\
#        -I
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\..\..\..\..\3rd-party\drivers\cmsis\device\ST\STM32F4xx\Include\
#        -I
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\..\..\..\..\3rd-party\drivers\libusb_stm32\inc\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\uac-otgfs-spi-i2s\List\system_stm32f4xx.lst
#    Object file       =
#        C:\Programming\Microcontrollers\Devices\apps\usb-device\uac-dac\iar-stm32f411ce\uac-otgfs-spi-i2s\Obj\system_stm32f4xx.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Programming\Microcontrollers\Devices\3rd-party\drivers\cmsis\device\ST\STM32F4xx\Source\Templates\system_stm32f4xx.c
      1          /**
      2            ******************************************************************************
      3            * @file    system_stm32f4xx.c
      4            * @author  MCD Application Team
      5            * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer System Source File.
      6            *
      7            *   This file provides two functions and one global variable to be called from 
      8            *   user application:
      9            *      - SystemInit(): This function is called at startup just after reset and 
     10            *                      before branch to main program. This call is made inside
     11            *                      the "startup_stm32f4xx.s" file.
     12            *
     13            *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
     14            *                                  by the user application to setup the SysTick 
     15            *                                  timer or configure other parameters.
     16            *                                     
     17            *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
     18            *                                 be called whenever the core clock is changed
     19            *                                 during program execution.
     20            *
     21            *
     22            ******************************************************************************
     23            * @attention
     24            *
     25            * <h2><center>&copy; COPYRIGHT 2017 STMicroelectronics</center></h2>
     26            *
     27            * Redistribution and use in source and binary forms, with or without modification,
     28            * are permitted provided that the following conditions are met:
     29            *   1. Redistributions of source code must retain the above copyright notice,
     30            *      this list of conditions and the following disclaimer.
     31            *   2. Redistributions in binary form must reproduce the above copyright notice,
     32            *      this list of conditions and the following disclaimer in the documentation
     33            *      and/or other materials provided with the distribution.
     34            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     35            *      may be used to endorse or promote products derived from this software
     36            *      without specific prior written permission.
     37            *
     38            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     39            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     40            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     41            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     42            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     43            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     44            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     45            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     46            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     47            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     48            *
     49            ******************************************************************************
     50            */
     51          
     52          /** @addtogroup CMSIS
     53            * @{
     54            */
     55          
     56          /** @addtogroup stm32f4xx_system
     57            * @{
     58            */  
     59            
     60          /** @addtogroup STM32F4xx_System_Private_Includes
     61            * @{
     62            */
     63          
     64          
     65          #include "stm32f4xx.h"
     66          
     67          #if !defined  (HSE_VALUE) 
     68            #define HSE_VALUE    ((uint32_t)25000000) /*!< Default value of the External oscillator in Hz */
     69          #endif /* HSE_VALUE */
     70          
     71          #if !defined  (HSI_VALUE)
     72            #define HSI_VALUE    ((uint32_t)16000000) /*!< Value of the Internal oscillator in Hz*/
     73          #endif /* HSI_VALUE */
     74          
     75          /**
     76            * @}
     77            */
     78          
     79          /** @addtogroup STM32F4xx_System_Private_TypesDefinitions
     80            * @{
     81            */
     82          
     83          /**
     84            * @}
     85            */
     86          
     87          /** @addtogroup STM32F4xx_System_Private_Defines
     88            * @{
     89            */
     90          
     91          /************************* Miscellaneous Configuration ************************/
     92          /*!< Uncomment the following line if you need to use external SRAM or SDRAM as data memory  */
     93          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)\
     94           || defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
     95           || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx)
     96          /* #define DATA_IN_ExtSRAM */
     97          #endif /* STM32F40xxx || STM32F41xxx || STM32F42xxx || STM32F43xxx || STM32F469xx || STM32F479xx ||\
     98                    STM32F412Zx || STM32F412Vx */
     99           
    100          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    101           || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
    102          /* #define DATA_IN_ExtSDRAM */
    103          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx ||\
    104                    STM32F479xx */
    105          
    106          /*!< Uncomment the following line if you need to relocate your vector Table in
    107               Internal SRAM. */
    108          /* #define VECT_TAB_SRAM */
    109          #define VECT_TAB_OFFSET  0x00 /*!< Vector Table base offset field. 
    110                                             This value must be a multiple of 0x200. */
    111          /******************************************************************************/
    112          
    113          /**
    114            * @}
    115            */
    116          
    117          /** @addtogroup STM32F4xx_System_Private_Macros
    118            * @{
    119            */
    120          
    121          /**
    122            * @}
    123            */
    124          
    125          /** @addtogroup STM32F4xx_System_Private_Variables
    126            * @{
    127            */
    128            /* This variable is updated in three ways:
    129                1) by calling CMSIS function SystemCoreClockUpdate()
    130                2) by calling HAL API function HAL_RCC_GetHCLKFreq()
    131                3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency 
    132                   Note: If you use this function to configure the system clock; then there
    133                         is no need to call the 2 first functions listed above, since SystemCoreClock
    134                         variable is updated automatically.
    135            */
    136          uint32_t SystemCoreClock = 16000000;
    137          const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
    138          const uint8_t APBPrescTable[8]  = {0, 0, 0, 0, 1, 2, 3, 4};
    139          /**
    140            * @}
    141            */
    142          
    143          /** @addtogroup STM32F4xx_System_Private_FunctionPrototypes
    144            * @{
    145            */
    146          
    147          #if defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)
    148            static void SystemInit_ExtMemCtl(void); 
    149          #endif /* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */
    150          
    151          /**
    152            * @}
    153            */
    154          
    155          /** @addtogroup STM32F4xx_System_Private_Functions
    156            * @{
    157            */
    158          
    159          /**
    160            * @brief  Setup the microcontroller system
    161            *         Initialize the FPU setting, vector table location and External memory 
    162            *         configuration.
    163            * @param  None
    164            * @retval None
    165            */
    166          void SystemInit(void)
    167          {
    168            /* FPU settings ------------------------------------------------------------*/
    169            #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    170              SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
    171            #endif
    172          
    173          #if defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)
    174            SystemInit_ExtMemCtl(); 
    175          #endif /* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */
    176          
    177            /* Configure the Vector Table location add offset address ------------------*/
    178          #ifdef VECT_TAB_SRAM
    179            SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
    180          #else
    181            SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
    182          #endif
    183          }
    184          
    185          /**
    186             * @brief  Update SystemCoreClock variable according to Clock Register Values.
    187            *         The SystemCoreClock variable contains the core clock (HCLK), it can
    188            *         be used by the user application to setup the SysTick timer or configure
    189            *         other parameters.
    190            *           
    191            * @note   Each time the core clock (HCLK) changes, this function must be called
    192            *         to update SystemCoreClock variable value. Otherwise, any configuration
    193            *         based on this variable will be incorrect.         
    194            *     
    195            * @note   - The system frequency computed by this function is not the real 
    196            *           frequency in the chip. It is calculated based on the predefined 
    197            *           constant and the selected clock source:
    198            *             
    199            *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
    200            *                                              
    201            *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
    202            *                          
    203            *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) 
    204            *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
    205            *         
    206            *         (*) HSI_VALUE is a constant defined in stm32f4xx_hal_conf.h file (default value
    207            *             16 MHz) but the real value may vary depending on the variations
    208            *             in voltage and temperature.   
    209            *    
    210            *         (**) HSE_VALUE is a constant defined in stm32f4xx_hal_conf.h file (its value
    211            *              depends on the application requirements), user has to ensure that HSE_VALUE
    212            *              is same as the real frequency of the crystal used. Otherwise, this function
    213            *              may have wrong result.
    214            *                
    215            *         - The result of this function could be not correct when using fractional
    216            *           value for HSE crystal.
    217            *     
    218            * @param  None
    219            * @retval None
    220            */
    221          void SystemCoreClockUpdate(void)
    222          {
    223            uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
    224            
    225            /* Get SYSCLK source -------------------------------------------------------*/
    226            tmp = RCC->CFGR & RCC_CFGR_SWS;
    227          
    228            switch (tmp)
    229            {
    230              case 0x00:  /* HSI used as system clock source */
    231                SystemCoreClock = HSI_VALUE;
    232                break;
    233              case 0x04:  /* HSE used as system clock source */
    234                SystemCoreClock = HSE_VALUE;
    235                break;
    236              case 0x08:  /* PLL used as system clock source */
    237          
    238                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
    239                   SYSCLK = PLL_VCO / PLL_P
    240                   */    
    241                pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
    242                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
    243                
    244                if (pllsource != 0)
    245                {
    246                  /* HSE used as PLL clock source */
    247                  pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
    248                }
    249                else
    250                {
    251                  /* HSI used as PLL clock source */
    252                  pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
    253                }
    254          
    255                pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
    256                SystemCoreClock = pllvco/pllp;
    257                break;
    258              default:
    259                SystemCoreClock = HSI_VALUE;
    260                break;
    261            }
    262            /* Compute HCLK frequency --------------------------------------------------*/
    263            /* Get HCLK prescaler */
    264            tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
    265            /* HCLK frequency */
    266            SystemCoreClock >>= tmp;
    267          }
    268          
    269          #if defined (DATA_IN_ExtSRAM) && defined (DATA_IN_ExtSDRAM)
    270          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    271           || defined(STM32F469xx) || defined(STM32F479xx)
    272          /**
    273            * @brief  Setup the external memory controller.
    274            *         Called in startup_stm32f4xx.s before jump to main.
    275            *         This function configures the external memories (SRAM/SDRAM)
    276            *         This SRAM/SDRAM will be used as program data memory (including heap and stack).
    277            * @param  None
    278            * @retval None
    279            */
    280          void SystemInit_ExtMemCtl(void)
    281          {
    282            __IO uint32_t tmp = 0x00;
    283          
    284            register uint32_t tmpreg = 0, timeout = 0xFFFF;
    285            register __IO uint32_t index;
    286          
    287            /* Enable GPIOC, GPIOD, GPIOE, GPIOF, GPIOG, GPIOH and GPIOI interface clock */
    288            RCC->AHB1ENR |= 0x000001F8;
    289          
    290            /* Delay after an RCC peripheral clock enabling */
    291            tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);
    292            
    293            /* Connect PDx pins to FMC Alternate function */
    294            GPIOD->AFR[0]  = 0x00CCC0CC;
    295            GPIOD->AFR[1]  = 0xCCCCCCCC;
    296            /* Configure PDx pins in Alternate function mode */  
    297            GPIOD->MODER   = 0xAAAA0A8A;
    298            /* Configure PDx pins speed to 100 MHz */  
    299            GPIOD->OSPEEDR = 0xFFFF0FCF;
    300            /* Configure PDx pins Output type to push-pull */  
    301            GPIOD->OTYPER  = 0x00000000;
    302            /* No pull-up, pull-down for PDx pins */ 
    303            GPIOD->PUPDR   = 0x00000000;
    304          
    305            /* Connect PEx pins to FMC Alternate function */
    306            GPIOE->AFR[0]  = 0xC00CC0CC;
    307            GPIOE->AFR[1]  = 0xCCCCCCCC;
    308            /* Configure PEx pins in Alternate function mode */ 
    309            GPIOE->MODER   = 0xAAAA828A;
    310            /* Configure PEx pins speed to 100 MHz */ 
    311            GPIOE->OSPEEDR = 0xFFFFC3CF;
    312            /* Configure PEx pins Output type to push-pull */  
    313            GPIOE->OTYPER  = 0x00000000;
    314            /* No pull-up, pull-down for PEx pins */ 
    315            GPIOE->PUPDR   = 0x00000000;
    316            
    317            /* Connect PFx pins to FMC Alternate function */
    318            GPIOF->AFR[0]  = 0xCCCCCCCC;
    319            GPIOF->AFR[1]  = 0xCCCCCCCC;
    320            /* Configure PFx pins in Alternate function mode */   
    321            GPIOF->MODER   = 0xAA800AAA;
    322            /* Configure PFx pins speed to 50 MHz */ 
    323            GPIOF->OSPEEDR = 0xAA800AAA;
    324            /* Configure PFx pins Output type to push-pull */  
    325            GPIOF->OTYPER  = 0x00000000;
    326            /* No pull-up, pull-down for PFx pins */ 
    327            GPIOF->PUPDR   = 0x00000000;
    328          
    329            /* Connect PGx pins to FMC Alternate function */
    330            GPIOG->AFR[0]  = 0xCCCCCCCC;
    331            GPIOG->AFR[1]  = 0xCCCCCCCC;
    332            /* Configure PGx pins in Alternate function mode */ 
    333            GPIOG->MODER   = 0xAAAAAAAA;
    334            /* Configure PGx pins speed to 50 MHz */ 
    335            GPIOG->OSPEEDR = 0xAAAAAAAA;
    336            /* Configure PGx pins Output type to push-pull */  
    337            GPIOG->OTYPER  = 0x00000000;
    338            /* No pull-up, pull-down for PGx pins */ 
    339            GPIOG->PUPDR   = 0x00000000;
    340            
    341            /* Connect PHx pins to FMC Alternate function */
    342            GPIOH->AFR[0]  = 0x00C0CC00;
    343            GPIOH->AFR[1]  = 0xCCCCCCCC;
    344            /* Configure PHx pins in Alternate function mode */ 
    345            GPIOH->MODER   = 0xAAAA08A0;
    346            /* Configure PHx pins speed to 50 MHz */ 
    347            GPIOH->OSPEEDR = 0xAAAA08A0;
    348            /* Configure PHx pins Output type to push-pull */  
    349            GPIOH->OTYPER  = 0x00000000;
    350            /* No pull-up, pull-down for PHx pins */ 
    351            GPIOH->PUPDR   = 0x00000000;
    352            
    353            /* Connect PIx pins to FMC Alternate function */
    354            GPIOI->AFR[0]  = 0xCCCCCCCC;
    355            GPIOI->AFR[1]  = 0x00000CC0;
    356            /* Configure PIx pins in Alternate function mode */ 
    357            GPIOI->MODER   = 0x0028AAAA;
    358            /* Configure PIx pins speed to 50 MHz */ 
    359            GPIOI->OSPEEDR = 0x0028AAAA;
    360            /* Configure PIx pins Output type to push-pull */  
    361            GPIOI->OTYPER  = 0x00000000;
    362            /* No pull-up, pull-down for PIx pins */ 
    363            GPIOI->PUPDR   = 0x00000000;
    364            
    365          /*-- FMC Configuration -------------------------------------------------------*/
    366            /* Enable the FMC interface clock */
    367            RCC->AHB3ENR |= 0x00000001;
    368            /* Delay after an RCC peripheral clock enabling */
    369            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    370          
    371            FMC_Bank5_6->SDCR[0] = 0x000019E4;
    372            FMC_Bank5_6->SDTR[0] = 0x01115351;      
    373            
    374            /* SDRAM initialization sequence */
    375            /* Clock enable command */
    376            FMC_Bank5_6->SDCMR = 0x00000011; 
    377            tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    378            while((tmpreg != 0) && (timeout-- > 0))
    379            {
    380              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    381            }
    382          
    383            /* Delay */
    384            for (index = 0; index<1000; index++);
    385            
    386            /* PALL command */
    387            FMC_Bank5_6->SDCMR = 0x00000012;           
    388            timeout = 0xFFFF;
    389            while((tmpreg != 0) && (timeout-- > 0))
    390            {
    391              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    392            }
    393            
    394            /* Auto refresh command */
    395            FMC_Bank5_6->SDCMR = 0x00000073;
    396            timeout = 0xFFFF;
    397            while((tmpreg != 0) && (timeout-- > 0))
    398            {
    399              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    400            }
    401           
    402            /* MRD register program */
    403            FMC_Bank5_6->SDCMR = 0x00046014;
    404            timeout = 0xFFFF;
    405            while((tmpreg != 0) && (timeout-- > 0))
    406            {
    407              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    408            } 
    409            
    410            /* Set refresh count */
    411            tmpreg = FMC_Bank5_6->SDRTR;
    412            FMC_Bank5_6->SDRTR = (tmpreg | (0x0000027C<<1));
    413            
    414            /* Disable write protection */
    415            tmpreg = FMC_Bank5_6->SDCR[0]; 
    416            FMC_Bank5_6->SDCR[0] = (tmpreg & 0xFFFFFDFF);
    417          
    418          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
    419            /* Configure and enable Bank1_SRAM2 */
    420            FMC_Bank1->BTCR[2]  = 0x00001011;
    421            FMC_Bank1->BTCR[3]  = 0x00000201;
    422            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    423          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */ 
    424          #if defined(STM32F469xx) || defined(STM32F479xx)
    425            /* Configure and enable Bank1_SRAM2 */
    426            FMC_Bank1->BTCR[2]  = 0x00001091;
    427            FMC_Bank1->BTCR[3]  = 0x00110212;
    428            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    429          #endif /* STM32F469xx || STM32F479xx */
    430          
    431            (void)(tmp); 
    432          }
    433          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
    434          #elif defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)
    435          /**
    436            * @brief  Setup the external memory controller.
    437            *         Called in startup_stm32f4xx.s before jump to main.
    438            *         This function configures the external memories (SRAM/SDRAM)
    439            *         This SRAM/SDRAM will be used as program data memory (including heap and stack).
    440            * @param  None
    441            * @retval None
    442            */
    443          void SystemInit_ExtMemCtl(void)
    444          {
    445            __IO uint32_t tmp = 0x00;
    446          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    447           || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
    448          #if defined (DATA_IN_ExtSDRAM)
    449            register uint32_t tmpreg = 0, timeout = 0xFFFF;
    450            register __IO uint32_t index;
    451          
    452          #if defined(STM32F446xx)
    453            /* Enable GPIOA, GPIOC, GPIOD, GPIOE, GPIOF, GPIOG interface
    454                clock */
    455            RCC->AHB1ENR |= 0x0000007D;
    456          #else
    457            /* Enable GPIOC, GPIOD, GPIOE, GPIOF, GPIOG, GPIOH and GPIOI interface 
    458                clock */
    459            RCC->AHB1ENR |= 0x000001F8;
    460          #endif /* STM32F446xx */  
    461            /* Delay after an RCC peripheral clock enabling */
    462            tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);
    463            
    464          #if defined(STM32F446xx)
    465            /* Connect PAx pins to FMC Alternate function */
    466            GPIOA->AFR[0]  |= 0xC0000000;
    467            GPIOA->AFR[1]  |= 0x00000000;
    468            /* Configure PDx pins in Alternate function mode */
    469            GPIOA->MODER   |= 0x00008000;
    470            /* Configure PDx pins speed to 50 MHz */
    471            GPIOA->OSPEEDR |= 0x00008000;
    472            /* Configure PDx pins Output type to push-pull */
    473            GPIOA->OTYPER  |= 0x00000000;
    474            /* No pull-up, pull-down for PDx pins */
    475            GPIOA->PUPDR   |= 0x00000000;
    476          
    477            /* Connect PCx pins to FMC Alternate function */
    478            GPIOC->AFR[0]  |= 0x00CC0000;
    479            GPIOC->AFR[1]  |= 0x00000000;
    480            /* Configure PDx pins in Alternate function mode */
    481            GPIOC->MODER   |= 0x00000A00;
    482            /* Configure PDx pins speed to 50 MHz */
    483            GPIOC->OSPEEDR |= 0x00000A00;
    484            /* Configure PDx pins Output type to push-pull */
    485            GPIOC->OTYPER  |= 0x00000000;
    486            /* No pull-up, pull-down for PDx pins */
    487            GPIOC->PUPDR   |= 0x00000000;
    488          #endif /* STM32F446xx */
    489          
    490            /* Connect PDx pins to FMC Alternate function */
    491            GPIOD->AFR[0]  = 0x000000CC;
    492            GPIOD->AFR[1]  = 0xCC000CCC;
    493            /* Configure PDx pins in Alternate function mode */  
    494            GPIOD->MODER   = 0xA02A000A;
    495            /* Configure PDx pins speed to 50 MHz */  
    496            GPIOD->OSPEEDR = 0xA02A000A;
    497            /* Configure PDx pins Output type to push-pull */  
    498            GPIOD->OTYPER  = 0x00000000;
    499            /* No pull-up, pull-down for PDx pins */ 
    500            GPIOD->PUPDR   = 0x00000000;
    501          
    502            /* Connect PEx pins to FMC Alternate function */
    503            GPIOE->AFR[0]  = 0xC00000CC;
    504            GPIOE->AFR[1]  = 0xCCCCCCCC;
    505            /* Configure PEx pins in Alternate function mode */ 
    506            GPIOE->MODER   = 0xAAAA800A;
    507            /* Configure PEx pins speed to 50 MHz */ 
    508            GPIOE->OSPEEDR = 0xAAAA800A;
    509            /* Configure PEx pins Output type to push-pull */  
    510            GPIOE->OTYPER  = 0x00000000;
    511            /* No pull-up, pull-down for PEx pins */ 
    512            GPIOE->PUPDR   = 0x00000000;
    513          
    514            /* Connect PFx pins to FMC Alternate function */
    515            GPIOF->AFR[0]  = 0xCCCCCCCC;
    516            GPIOF->AFR[1]  = 0xCCCCCCCC;
    517            /* Configure PFx pins in Alternate function mode */   
    518            GPIOF->MODER   = 0xAA800AAA;
    519            /* Configure PFx pins speed to 50 MHz */ 
    520            GPIOF->OSPEEDR = 0xAA800AAA;
    521            /* Configure PFx pins Output type to push-pull */  
    522            GPIOF->OTYPER  = 0x00000000;
    523            /* No pull-up, pull-down for PFx pins */ 
    524            GPIOF->PUPDR   = 0x00000000;
    525          
    526            /* Connect PGx pins to FMC Alternate function */
    527            GPIOG->AFR[0]  = 0xCCCCCCCC;
    528            GPIOG->AFR[1]  = 0xCCCCCCCC;
    529            /* Configure PGx pins in Alternate function mode */ 
    530            GPIOG->MODER   = 0xAAAAAAAA;
    531            /* Configure PGx pins speed to 50 MHz */ 
    532            GPIOG->OSPEEDR = 0xAAAAAAAA;
    533            /* Configure PGx pins Output type to push-pull */  
    534            GPIOG->OTYPER  = 0x00000000;
    535            /* No pull-up, pull-down for PGx pins */ 
    536            GPIOG->PUPDR   = 0x00000000;
    537          
    538          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    539           || defined(STM32F469xx) || defined(STM32F479xx)  
    540            /* Connect PHx pins to FMC Alternate function */
    541            GPIOH->AFR[0]  = 0x00C0CC00;
    542            GPIOH->AFR[1]  = 0xCCCCCCCC;
    543            /* Configure PHx pins in Alternate function mode */ 
    544            GPIOH->MODER   = 0xAAAA08A0;
    545            /* Configure PHx pins speed to 50 MHz */ 
    546            GPIOH->OSPEEDR = 0xAAAA08A0;
    547            /* Configure PHx pins Output type to push-pull */  
    548            GPIOH->OTYPER  = 0x00000000;
    549            /* No pull-up, pull-down for PHx pins */ 
    550            GPIOH->PUPDR   = 0x00000000;
    551            
    552            /* Connect PIx pins to FMC Alternate function */
    553            GPIOI->AFR[0]  = 0xCCCCCCCC;
    554            GPIOI->AFR[1]  = 0x00000CC0;
    555            /* Configure PIx pins in Alternate function mode */ 
    556            GPIOI->MODER   = 0x0028AAAA;
    557            /* Configure PIx pins speed to 50 MHz */ 
    558            GPIOI->OSPEEDR = 0x0028AAAA;
    559            /* Configure PIx pins Output type to push-pull */  
    560            GPIOI->OTYPER  = 0x00000000;
    561            /* No pull-up, pull-down for PIx pins */ 
    562            GPIOI->PUPDR   = 0x00000000;
    563          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
    564            
    565          /*-- FMC Configuration -------------------------------------------------------*/
    566            /* Enable the FMC interface clock */
    567            RCC->AHB3ENR |= 0x00000001;
    568            /* Delay after an RCC peripheral clock enabling */
    569            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    570          
    571            /* Configure and enable SDRAM bank1 */
    572          #if defined(STM32F446xx)
    573            FMC_Bank5_6->SDCR[0] = 0x00001954;
    574          #else  
    575            FMC_Bank5_6->SDCR[0] = 0x000019E4;
    576          #endif /* STM32F446xx */
    577            FMC_Bank5_6->SDTR[0] = 0x01115351;      
    578            
    579            /* SDRAM initialization sequence */
    580            /* Clock enable command */
    581            FMC_Bank5_6->SDCMR = 0x00000011; 
    582            tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    583            while((tmpreg != 0) && (timeout-- > 0))
    584            {
    585              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    586            }
    587          
    588            /* Delay */
    589            for (index = 0; index<1000; index++);
    590            
    591            /* PALL command */
    592            FMC_Bank5_6->SDCMR = 0x00000012;           
    593            timeout = 0xFFFF;
    594            while((tmpreg != 0) && (timeout-- > 0))
    595            {
    596              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    597            }
    598            
    599            /* Auto refresh command */
    600          #if defined(STM32F446xx)
    601            FMC_Bank5_6->SDCMR = 0x000000F3;
    602          #else  
    603            FMC_Bank5_6->SDCMR = 0x00000073;
    604          #endif /* STM32F446xx */
    605            timeout = 0xFFFF;
    606            while((tmpreg != 0) && (timeout-- > 0))
    607            {
    608              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    609            }
    610           
    611            /* MRD register program */
    612          #if defined(STM32F446xx)
    613            FMC_Bank5_6->SDCMR = 0x00044014;
    614          #else  
    615            FMC_Bank5_6->SDCMR = 0x00046014;
    616          #endif /* STM32F446xx */
    617            timeout = 0xFFFF;
    618            while((tmpreg != 0) && (timeout-- > 0))
    619            {
    620              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    621            } 
    622            
    623            /* Set refresh count */
    624            tmpreg = FMC_Bank5_6->SDRTR;
    625          #if defined(STM32F446xx)
    626            FMC_Bank5_6->SDRTR = (tmpreg | (0x0000050C<<1));
    627          #else    
    628            FMC_Bank5_6->SDRTR = (tmpreg | (0x0000027C<<1));
    629          #endif /* STM32F446xx */
    630            
    631            /* Disable write protection */
    632            tmpreg = FMC_Bank5_6->SDCR[0]; 
    633            FMC_Bank5_6->SDCR[0] = (tmpreg & 0xFFFFFDFF);
    634          #endif /* DATA_IN_ExtSDRAM */
    635          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
    636          
    637          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)\
    638           || defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    639           || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx)
    640          
    641          #if defined(DATA_IN_ExtSRAM)
    642          /*-- GPIOs Configuration -----------------------------------------------------*/
    643             /* Enable GPIOD, GPIOE, GPIOF and GPIOG interface clock */
    644            RCC->AHB1ENR   |= 0x00000078;
    645            /* Delay after an RCC peripheral clock enabling */
    646            tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);
    647            
    648            /* Connect PDx pins to FMC Alternate function */
    649            GPIOD->AFR[0]  = 0x00CCC0CC;
    650            GPIOD->AFR[1]  = 0xCCCCCCCC;
    651            /* Configure PDx pins in Alternate function mode */  
    652            GPIOD->MODER   = 0xAAAA0A8A;
    653            /* Configure PDx pins speed to 100 MHz */  
    654            GPIOD->OSPEEDR = 0xFFFF0FCF;
    655            /* Configure PDx pins Output type to push-pull */  
    656            GPIOD->OTYPER  = 0x00000000;
    657            /* No pull-up, pull-down for PDx pins */ 
    658            GPIOD->PUPDR   = 0x00000000;
    659          
    660            /* Connect PEx pins to FMC Alternate function */
    661            GPIOE->AFR[0]  = 0xC00CC0CC;
    662            GPIOE->AFR[1]  = 0xCCCCCCCC;
    663            /* Configure PEx pins in Alternate function mode */ 
    664            GPIOE->MODER   = 0xAAAA828A;
    665            /* Configure PEx pins speed to 100 MHz */ 
    666            GPIOE->OSPEEDR = 0xFFFFC3CF;
    667            /* Configure PEx pins Output type to push-pull */  
    668            GPIOE->OTYPER  = 0x00000000;
    669            /* No pull-up, pull-down for PEx pins */ 
    670            GPIOE->PUPDR   = 0x00000000;
    671          
    672            /* Connect PFx pins to FMC Alternate function */
    673            GPIOF->AFR[0]  = 0x00CCCCCC;
    674            GPIOF->AFR[1]  = 0xCCCC0000;
    675            /* Configure PFx pins in Alternate function mode */   
    676            GPIOF->MODER   = 0xAA000AAA;
    677            /* Configure PFx pins speed to 100 MHz */ 
    678            GPIOF->OSPEEDR = 0xFF000FFF;
    679            /* Configure PFx pins Output type to push-pull */  
    680            GPIOF->OTYPER  = 0x00000000;
    681            /* No pull-up, pull-down for PFx pins */ 
    682            GPIOF->PUPDR   = 0x00000000;
    683          
    684            /* Connect PGx pins to FMC Alternate function */
    685            GPIOG->AFR[0]  = 0x00CCCCCC;
    686            GPIOG->AFR[1]  = 0x000000C0;
    687            /* Configure PGx pins in Alternate function mode */ 
    688            GPIOG->MODER   = 0x00085AAA;
    689            /* Configure PGx pins speed to 100 MHz */ 
    690            GPIOG->OSPEEDR = 0x000CAFFF;
    691            /* Configure PGx pins Output type to push-pull */  
    692            GPIOG->OTYPER  = 0x00000000;
    693            /* No pull-up, pull-down for PGx pins */ 
    694            GPIOG->PUPDR   = 0x00000000;
    695            
    696          /*-- FMC/FSMC Configuration --------------------------------------------------*/
    697            /* Enable the FMC/FSMC interface clock */
    698            RCC->AHB3ENR         |= 0x00000001;
    699          
    700          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
    701            /* Delay after an RCC peripheral clock enabling */
    702            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    703            /* Configure and enable Bank1_SRAM2 */
    704            FMC_Bank1->BTCR[2]  = 0x00001011;
    705            FMC_Bank1->BTCR[3]  = 0x00000201;
    706            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    707          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */ 
    708          #if defined(STM32F469xx) || defined(STM32F479xx)
    709            /* Delay after an RCC peripheral clock enabling */
    710            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    711            /* Configure and enable Bank1_SRAM2 */
    712            FMC_Bank1->BTCR[2]  = 0x00001091;
    713            FMC_Bank1->BTCR[3]  = 0x00110212;
    714            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    715          #endif /* STM32F469xx || STM32F479xx */
    716          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx)\
    717             || defined(STM32F412Zx) || defined(STM32F412Vx)
    718            /* Delay after an RCC peripheral clock enabling */
    719            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);
    720            /* Configure and enable Bank1_SRAM2 */
    721            FSMC_Bank1->BTCR[2]  = 0x00001011;
    722            FSMC_Bank1->BTCR[3]  = 0x00000201;
    723            FSMC_Bank1E->BWTR[2] = 0x0FFFFFFF;
    724          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx */
    725          
    726          #endif /* DATA_IN_ExtSRAM */
    727          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx ||\
    728                    STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx  */ 
    729            (void)(tmp); 
    730          }
    731          #endif /* DATA_IN_ExtSRAM && DATA_IN_ExtSDRAM */
    732          /**
    733            * @}
    734            */
    735          
    736          /**
    737            * @}
    738            */
    739          
    740          /**
    741            * @}
    742            */
    743          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SystemCoreClockUpdate
       0   SystemInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
      16  AHBPrescTable
       8  APBPrescTable
       4  SystemCoreClock
     162  SystemCoreClockUpdate
      20  SystemInit

 
   4 bytes in section .data
  24 bytes in section .rodata
 214 bytes in section .text
 
 214 bytes of CODE  memory
  24 bytes of CONST memory
   4 bytes of DATA  memory

Errors: none
Warnings: none
